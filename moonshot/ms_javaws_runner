#!/usr/bin/env python3
"""Python rewrite of ms_javaws_runner bash script.

Features:
- Runs in continuous mode by default: waits for JNLP file, launches, waits for exit, cleans up, repeats.
- Checks for existing running Java Web Start process matching a pattern (default 'jweblauncher').
- Launches `javaws` with a provided JNLP file.
- Sleeps a configurable amount to allow process startup.
- Displays a spinner while waiting for the process to exit.
- Removes the JNLP file on completion.
- Supports a dry-run mode for testing without side effects.
- Use --once flag to run a single cycle instead of continuous mode.
"""
from __future__ import annotations
import argparse
import logging
import os
import shutil
import sys
import time
import subprocess
import xml.etree.ElementTree as ET
from typing import Sequence


def get_pyfiglet_output(text: str) -> None:
    """Run pyfiglet to display text in ASCII art."""
    # see where pyfilget is installed

    # if `uv run pyfiglet a` is non-zero use it, else try pyfilget, else fallback to print
    uv_pyfiglet_output = subprocess.run(["uv", "run", "pyfiglet", text], check=False, stdout=subprocess.PIPE, text=True)
    if uv_pyfiglet_output.returncode == 0:
        output = uv_pyfiglet_output.stdout.rstrip()
    elif shutil.which("pyfiglet"):
        pass
        output = subprocess.check_output(["pyfiglet", text], text=True).rstrip()
    else:
        output = text
    return output


def process_running(pattern: str) -> bool:
    """Return True if any process matches pattern using `pgrep -f`.
    Falls back to manual `ps` scan if pgrep unavailable.
    """
    try:
        proc = subprocess.run(["pgrep", "-f", pattern], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return proc.returncode == 0
    except FileNotFoundError:
        # Fallback: parse ps output
        try:
            ps = subprocess.check_output(["ps", "-axo", "pid,args"], text=True, errors="ignore")
        except Exception:
            return False
        pattern_lower = pattern.lower()
        for line in ps.splitlines():
            if pattern_lower in line.lower():
                return True
        return False


def parse_jnlp_port(jnlp_path: str) -> int | None:
    """Parse JNLP file and extract port number from codebase attribute.
    Returns port number or None if not found/invalid.
    """
    try:
        tree = ET.parse(jnlp_path)
        root = tree.getroot()
        codebase = root.get('codebase')
        if codebase:
            # Extract port from URL like "https://moon-chassis-2.inband.releng.mdc1.mozilla.com:737"
            if ':' in codebase:
                port_str = codebase.rsplit(':', 1)[1]
                # Remove any trailing path
                port_str = port_str.split('/')[0]
                return int(port_str)
    except Exception as e:
        logging.debug(f"Failed to parse JNLP port: {e}")
    return None


def port_to_cartridge(port: int) -> int:
    """Convert port number to cartridge number.
    Cartridge 1 is at port 736, cartridge 2 at 737, etc.
    """
    return port - 735


def launch_javaws(jnlp_path: str, dry_run: bool) -> int:
    """Launch javaws with the given JNLP file. Returns the exit code of the javaws process.
    In dry-run mode, just prints the command and returns 0.
    """
    # Parse and display cartridge info
    port = parse_jnlp_port(jnlp_path)
    if port:
        cartridge = port_to_cartridge(port)
        # print(f"Connecting to cartridge {cartridge} (port {port})")
        # use pyflget to print the cartridge number
        print(f"[info] JNLP indicates cartridge {cartridge} (port {port})")
        print(get_pyfiglet_output(f"Cartridge {cartridge}"))
    else:
        print("[info] Could not determine cartridge number from JNLP.")
        sys.exit(1)

    cmd = ["javaws", jnlp_path]
    if dry_run:
        print(f"[dry-run] Would execute: {' '.join(cmd)}")
        return 0
    try:
        proc = subprocess.Popen(cmd)
    except FileNotFoundError:
        print("Error: 'javaws' command not found in PATH.", file=sys.stderr)
        return 127
    except Exception as e:
        print(f"Error launching javaws: {e}", file=sys.stderr)
        return 1
    return proc.pid  # Return PID to indicate success; we don't wait here.


def wait_for_process_exit(pattern: str, spinner_interval: float = 0.1) -> None:
    """Wait until no process matches the pattern, showing a spinner."""
    spinner = ["-", "\\", "|", "/"]
    idx = 0
    sys.stdout.write(f"[waiting] {spinner[0]}")
    sys.stdout.flush()
    while process_running(pattern):
        sys.stdout.write("\b" + spinner[idx])
        sys.stdout.flush()
        time.sleep(spinner_interval)
        idx = (idx + 1) % len(spinner)
    sys.stdout.write("\b ")  # clear spinner char
    sys.stdout.write("\n")
    sys.stdout.flush()


def remove_file(path: str, dry_run: bool) -> None:
    if dry_run:
        print(f"[dry-run] Would remove: {path}")
        return
    if not os.path.exists(path):
        print(f"Note: File already absent: {path}")
        return
    try:
        os.remove(path)
        print(f"Removed file: {path}")
    except Exception as e:
        print(f"Error removing file '{path}': {e}", file=sys.stderr)


def parse_args(argv: Sequence[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Run a JNLP via javaws and wait for its process to exit. Runs in continuous mode by default.")
    parser.add_argument("--jnlp", default="$HOME/Downloads/moonshot-jirc.jnlp", help="Path to JNLP file to launch (default: %(default)s)")
    parser.add_argument("--pattern", default="jweblauncher", help="Process name/pattern to monitor (default: %(default)s)")
    parser.add_argument("--sleep", type=int, default=35, help="Seconds to sleep allowing process to start (default: %(default)s)")
    parser.add_argument("--spinner-interval", type=float, default=0.1, help="Seconds per spinner tick (default: %(default)s)")
    parser.add_argument("--dry-run", action="store_true", help="Do not execute or remove anything; just print actions")
    parser.add_argument("--no-remove", action="store_true", help="Skip removing the JNLP file at end")
    parser.add_argument("--once", action="store_true", help="Run once and exit instead of continuous polling mode")
    parser.add_argument("--poll-interval", type=int, default=5, help="Seconds to wait between JNLP checks in continuous mode (default: %(default)s)")
    return parser.parse_args(argv)


def run_once(args: argparse.Namespace) -> int:
    """Execute one cycle: check process, launch, wait, cleanup.
    Assumes JNLP file already exists (caller should ensure this)."""
    # Pre-check existing process
    if process_running(args.pattern):
        print(f"Error: A process matching '{args.pattern}' is already running. Close it before running this script.")
        return 1

    # Verify JNLP file exists (should already be ensured by caller)
    if not os.path.exists(args.jnlp):
        print(f"Error: JNLP file not found: {args.jnlp}")
        return 1

    # Launch javaws
    pid_or_code = launch_javaws(args.jnlp, args.dry_run)
    if isinstance(pid_or_code, int) and pid_or_code in (1, 127):
        # Error codes from launch function
        return pid_or_code

    print(f"Sleeping {args.sleep} seconds to allow '{args.pattern}' to start...")
    time.sleep(args.sleep)

    print(f"Waiting for process matching '{args.pattern}' to exit...")
    wait_for_process_exit(args.pattern, args.spinner_interval)

    print(f"Process '{args.pattern}' has exited.")

    if not args.no_remove:
        print("Removing JNLP file...")
        remove_file(args.jnlp, args.dry_run)
    else:
        print("Skipping JNLP file removal per --no-remove.")

    return 0


def main(argv: Sequence[str] | None = None) -> int:
    args = parse_args(argv or sys.argv[1:])

    # expand $HOME in args.jnlp
    args.jnlp = os.path.expandvars(os.path.expanduser(args.jnlp))

    if args.once:
        # Single run mode: wait for file, run once, exit
        print(f"Waiting for JNLP file: {args.jnlp} (checking every {args.poll_interval}s)...")
        while not os.path.exists(args.jnlp):
            time.sleep(args.poll_interval)
        print(f"JNLP file found: {args.jnlp}")
        time.sleep(1)  # ensure downloaded file is complete
        return run_once(args)
    else:
        # Continuous mode (default)
        print(f"[continuous-mode] Polling for JNLP every {args.poll_interval}s. Press Ctrl+C to stop.")
        cycle = 0
        try:
            while True:
                cycle += 1
                print(f"\n--- Cycle {cycle} ---")

                # Wait for JNLP to appear
                print(f"Waiting for JNLP file: {args.jnlp} (checking every {args.poll_interval}s)...")
                while not os.path.exists(args.jnlp):
                    time.sleep(args.poll_interval)

                print(f"JNLP file found: {args.jnlp}")
                time.sleep(1)  # ensure downloaded file is complete

                # Run one cycle
                exit_code = run_once(args)
                if exit_code != 0:
                    print(f"Cycle failed with code {exit_code}. Continuing...")

                print(f"Cycle {cycle} complete. Waiting {args.poll_interval}s before next check...")
                time.sleep(args.poll_interval)
        except KeyboardInterrupt:
            print("\n[continuous-mode] Interrupted by user. Exiting.")
            return 0


if __name__ == "__main__":  # pragma: no cover
    sys.exit(main())
